using KernelBuilder.Algorithms;
using static KernelBuilder.Common;

namespace KernelBuilder
{
    class KernelCodeGenerator
    {
        public static CodeList GenerateImports(AttackVector attackVector)
        {
            CodeList code = new CodeList();

            code.Add("""
                 /**
                 * Plugin has been auto-generated by https://github.com/PenguinKeeper7/KernelBuilder
                 * DO NOT PR into hashcat master
                 */

                 /**
                 * Author......: See docs/credits.txt
                 * License.....: MIT
                 */
                 """);

            if (attackVector == AttackVector.a3)
                code.Add("#define NEW_SIMD_CODE");

            code.Add("""
                #ifdef KERNEL_STATIC
                #include M2S(INCLUDE_PATH/inc_vendor.h)
                #include M2S(INCLUDE_PATH/inc_types.h)
                #include M2S(INCLUDE_PATH/inc_platform.cl)
                #include M2S(INCLUDE_PATH/inc_common.cl)
                """);

            if (attackVector == AttackVector.a3)
            {
                code.Add("#include M2S(INCLUDE_PATH/inc_simd.cl)");
            }
            else
            {
                code.Add("""
                #include M2S(INCLUDE_PATH/inc_rp.h)
                #include M2S(INCLUDE_PATH/inc_rp.cl)
                #include M2S(INCLUDE_PATH/inc_scalar.cl)
                """);
            }

            code.Add("""
                #include M2S(INCLUDE_PATH/inc_hash_md5.cl)
                #include M2S(INCLUDE_PATH/inc_hash_sha1.cl)
                #include M2S(INCLUDE_PATH/inc_hash_sha224.cl)
                #include M2S(INCLUDE_PATH/inc_hash_sha256.cl)
                #endif

                #if   VECT_SIZE == 1
                #define uint_to_hex_lower8(i) make_u32x (l_bin2asc[(i)])
                #elif VECT_SIZE == 2
                #define uint_to_hex_lower8(i) make_u32x (l_bin2asc[(i).s0], l_bin2asc[(i).s1])
                #elif VECT_SIZE == 4
                #define uint_to_hex_lower8(i) make_u32x (l_bin2asc[(i).s0], l_bin2asc[(i).s1], l_bin2asc[(i).s2], l_bin2asc[(i).s3])
                #elif VECT_SIZE == 8
                #define uint_to_hex_lower8(i) make_u32x (l_bin2asc[(i).s0], l_bin2asc[(i).s1], l_bin2asc[(i).s2], l_bin2asc[(i).s3], l_bin2asc[(i).s4], l_bin2asc[(i).s5], l_bin2asc[(i).s6], l_bin2asc[(i).s7])
                #elif VECT_SIZE == 16
                #define uint_to_hex_lower8(i) make_u32x (l_bin2asc[(i).s0], l_bin2asc[(i).s1], l_bin2asc[(i).s2], l_bin2asc[(i).s3], l_bin2asc[(i).s4], l_bin2asc[(i).s5], l_bin2asc[(i).s6], l_bin2asc[(i).s7], l_bin2asc[(i).s8], l_bin2asc[(i).s9], l_bin2asc[(i).sa], l_bin2asc[(i).sb], l_bin2asc[(i).sc], l_bin2asc[(i).sd], l_bin2asc[(i).se], l_bin2asc[(i).sf])
                #endif

                #if   VECT_SIZE == 1
                #define uint_to_hex_lower8_le(i) make_u32x (l_bin2asc_le[(i)])
                #elif VECT_SIZE == 2
                #define uint_to_hex_lower8_le(i) make_u32x (l_bin2asc_le[(i).s0], l_bin2asc_le[(i).s1])
                #elif VECT_SIZE == 4
                #define uint_to_hex_lower8_le(i) make_u32x (l_bin2asc_le[(i).s0], l_bin2asc_le[(i).s1], l_bin2asc_le[(i).s2], l_bin2asc_le[(i).s3])
                #elif VECT_SIZE == 8
                #define uint_to_hex_lower8_le(i) make_u32x (l_bin2asc_le[(i).s0], l_bin2asc_le[(i).s1], l_bin2asc_le[(i).s2], l_bin2asc_le[(i).s3], l_bin2asc_le[(i).s4], l_bin2asc_le[(i).s5], l_bin2asc_le[(i).s6], l_bin2asc_le[(i).s7])
                #elif VECT_SIZE == 16
                #define uint_to_hex_lower8_le(i) make_u32x (l_bin2asc_le[(i).s0], l_bin2asc_le[(i).s1], l_bin2asc_le[(i).s2], l_bin2asc_le[(i).s3], l_bin2asc_le[(i).s4], l_bin2asc_le[(i).s5], l_bin2asc_le[(i).s6], l_bin2asc_le[(i).s7], l_bin2asc_le[(i).s8], l_bin2asc_le[(i).s9], l_bin2asc_le[(i).sa], l_bin2asc_le[(i).sb], l_bin2asc_le[(i).sc], l_bin2asc_le[(i).sd], l_bin2asc_le[(i).se], l_bin2asc_le[(i).sf])
                #endif
                """
            );
                

            code.Add("");

            return code;
        }

        public static CodeList GenerateHeader(List<string> instructions, KernelType kernelType, AttackVector attackVector, string hashMode)
        {
            CodeList code = new CodeList();

            string functionNameSuffix = "";

            // mxx vs sxx in the function name
            if (kernelType == KernelType.SingleHash)
                functionNameSuffix = "s";
            else
                functionNameSuffix = "m";

            string argument = "";

            if (attackVector == AttackVector.a0)
                argument = "KERN_ATTR_RULES ()";
            else if (attackVector == AttackVector.a1)
                argument = "KERN_ATTR_BASIC ()";
            else if (attackVector == AttackVector.a3)
                argument = "KERN_ATTR_VECTOR ()";
            else
                // Should never be called but here for safety
                throw new NotImplementedException("Unknown -a mode");

            code.Add($"KERNEL_FQ KERNEL_FA void m{hashMode}_{functionNameSuffix}xx ({argument})", 0);

            code.Add("""
            {
            /**
                * modifier
                */

            const u64 gid = get_global_id (0);
            const u64 lid = get_local_id (0);
            const u64 lsz = get_local_size (0);

            /**
                * both encoding bin2asc tables
                */

            LOCAL_VK u32 l_bin2asc[256];
            LOCAL_VK u32 l_bin2asc_le[256];

            for (u32 i = lid; i < 256; i += lsz)
            {
                const u32 i0 = (i >> 0) & 15;
                const u32 i1 = (i >> 4) & 15;

                l_bin2asc[i] = ((i0 < 10) ? '0' + i0 : 'a' - 10 + i0) << 8
                            | ((i1 < 10) ? '0' + i1 : 'a' - 10 + i1) << 0;
                l_bin2asc_le[i] = ((i0 < 10) ? '0' + i0 : 'a' - 10 + i0) << 0
                            | ((i1 < 10) ? '0' + i1 : 'a' - 10 + i1) << 8;
            }

            SYNC_THREADS ();

            if (gid >= GID_CNT) return;

            /**
                * digest
                */

            const u32 search[4] =
            {
                digests_buf[DIGESTS_OFFSET_HOST].digest_buf[DGST_R0],
                digests_buf[DIGESTS_OFFSET_HOST].digest_buf[DGST_R1],
                digests_buf[DIGESTS_OFFSET_HOST].digest_buf[DGST_R2],
                digests_buf[DIGESTS_OFFSET_HOST].digest_buf[DGST_R3]
            };

            /**
                * base
                */
            """, 1);

            if (attackVector == AttackVector.a0)
            {
                code.Add("COPY_PW (pws[gid]);", 1);
            }
            else
            {
                code.Add("""
                    const u32 pw_len = pws[gid].pw_len;
                    u32x w[64] = { 0 };
                    for (u32 i = 0, idx = 0; i < pw_len; i += 4, idx += 1)
                    {
                      w[idx] = pws[gid].i[idx];
                    }

                    u32x w0l = w[0];
                    """);
            }

            // Handle optional salts
            foreach (var instruction in instructions)
            {
                if (instruction.Contains("salt"))
                {
                    code.Add("""
                        const u32 salt_len = salt_bufs[SALT_POS_HOST].salt_len;
                        
                        u32 s[64] = { 0 };

                        for (u32 i = 0, idx = 0; i < salt_len; i += 4, idx += 1)
                        {
                          s[idx] = salt_bufs[SALT_POS_HOST].salt_buf[idx];
                        }
                        """, 1);
                    break;
                }
            }

            code.Add("""

                /**
                 * loop
                 */

                  u32 w0[4];
                  u32 w1[4];
                  u32 w2[4];
                  u32 w3[4];

                """,1 );

            if (attackVector == AttackVector.a3)
            {
                code.Add("for (u32 il_pos = 0; il_pos < IL_CNT; il_pos += VECT_SIZE)");
            }
            else
            {
                code.Add("for (u32 il_pos = 0; il_pos < IL_CNT; il_pos++)");
            }

            code.Add("{");
            code.spacing++;

            if (attackVector == AttackVector.a0)
            {
                code.Add("""
                    pw_t tmp = PASTE_PW;
                    tmp.pw_len = apply_rules (rules_buf[il_pos].cmds, tmp.i, tmp.pw_len);
                """, 1);
            }
            else if (attackVector == AttackVector.a3)
            {
                code.Add("""
                                    	
                    const u32x w0r = words_buf_r[il_pos / VECT_SIZE];

                    const u32x wStart = w0l | w0r;

                    w[0] = wStart;
                """);
            }

            code.Add("");

            return code;
        }

        public static CodeList GenerateCompute(List<string> instructions, AttackVector attackVector)
        {
            CodeList code = new CodeList();
            code.spacing = 2;

            // Key = context name | Value = algorithm
            Dictionary<string, IAlgorithm> contextAlgorithms = new Dictionary<string, IAlgorithm>();

            Dictionary<string, int> contextInputCounts = new Dictionary<string, int>();

            foreach (string instruction in instructions)
            {
                string context = instruction.Split(" - ")[0].Replace("-", "");
                if (contextInputCounts.ContainsKey(context))
                    contextInputCounts[context]++;
                else
                    contextInputCounts.Add(context, 1);
            }

            for (int idx = 0; idx < instructions.Count; idx++)
            {
                string instruction = instructions[idx];
                string context = instruction.Split(" - ")[0].Replace(" ", "").Replace("-", "");
                string input = instruction.Split(" - ")[1].Replace("-", "");
                string algorithmName = instruction.Split("-")[0];

                IAlgorithm currentAlgorithm;

                if (algorithmName.StartsWith("CUT"))
                {
                    int cutLength = int.Parse(context.Split("_").First().Replace("CUT", "")) / 2;

                    // Cleanup so the rest of the code doesn't know about the CUT and pretend nothing happened
                    algorithmName = instruction.Split("_").Last().Split("-").First();
                    instruction = instruction.Replace($"CUT{cutLength}_", "");

                    // Must entirely re-parse
                    currentAlgorithm = Common.parseAlgorithmName(algorithmName);

                    context = context.Split("_").Last();
                }
                else
                {
                    currentAlgorithm = Common.parseAlgorithmName(algorithmName);
                }

                currentAlgorithm.context = context;

                if (contextAlgorithms.ContainsKey(context) == false)
                {
                    contextAlgorithms.Add(context, currentAlgorithm);

                    if(attackVector != AttackVector.a3)
                    {
                        // md5_ctx_t ctx;
                        code.Add($"{currentAlgorithm.contextType} {context};");

                        // md5_init (&ctx);
                        code.Add($"{currentAlgorithm.initFunction} (&{context});");
                    }
                    else
                    {
                        // md5_ctx_vector_t ctx;
                        code.Add($"{currentAlgorithm.contextType.Replace("_t", "_vector_t")} {context};");

                        // md5_init_vector (&ctx);
                        code.Add($"{currentAlgorithm.initFunction}_vector (&{context});");
                    }

                    code.Add("");
                }

                // Re-parse CUTs for inputs
                if (input.StartsWith("CUT"))
                {
                    int cutLength = int.Parse(input.Split("_").First().Replace("CUT", "")) / 2;
                    if (cutLength % 4 != 0)
                        throw new NotSupportedException("CUT is not supported for values that are not multiples of 4.");

                    string contextToCut = instruction.Split("_").Last().Split(" - ")[0].Replace("-", "");
                    if (contextAlgorithms.ContainsKey(contextToCut) == false)
                        throw new NotSupportedException("CUT is not supported on raw values such as $plain or $salt.");

                    contextAlgorithms[contextToCut].byteLength = cutLength;

                    input = input.Split("_").Last();
                }

                if (input == "plain")
                {
                    if (currentAlgorithm.endianness == Common.Endianness.LittleEndian)
                    {
                        if (attackVector == AttackVector.a0)
                        {
                            // md5_update (&ctx, tmp.i, tmp.pw_len);
                            code.Add($"{currentAlgorithm.updateFunction}(&{context}, tmp.i, tmp.pw_len);");
                        }
                        else if (attackVector == AttackVector.a1)
                        {
                            // md5_update_global(&ctx, pws[gid].i, pws[gid].pw_len);
                            // md5_update_global(&ctx, combs_buf[il_pos].i, combs_buf[il_pos].pw_len);
                            code.Add($"""
                                {currentAlgorithm.updateGlobalFunction}(&{context}, pws[gid].i, pws[gid].pw_len);
                                {currentAlgorithm.updateGlobalFunction}(&{context}, combs_buf[il_pos].i, combs_buf[il_pos].pw_len);
                            """);
                        }
                        else
                        {
                            // md5_update_vector (&ctx, w, pw_len);
                            code.Add($"""
                                {currentAlgorithm.updateFunction}_vector (&{context}, w, pw_len);
                            """);
                        }
                    }
                    else // Big-endian algorithm
                    {
                        if (attackVector == AttackVector.a0)
                        {
                            // md5_update_swap (&ctx, tmp.i, tmp.pw_len);
                            code.Add($"{currentAlgorithm.updateSwapFunction}(&{context}, tmp.i, tmp.pw_len);");
                        }
                        else if (attackVector == AttackVector.a1)
                        {
                            // sha1_update_global_swap(&ctx, pws[gid].i, pws[gid].pw_len);
                            // sha1_update_global_swap(&ctx, combs_buf[il_pos].i, combs_buf[il_pos].pw_len);
                            code.Add($"""
                                {currentAlgorithm.updateGlobalSwapFunction}(&{context}, pws[gid].i, pws[gid].pw_len);
                                {currentAlgorithm.updateGlobalSwapFunction}(&{context}, combs_buf[il_pos].i, combs_buf[il_pos].pw_len);
                            """);
                        }
                        else
                        {
                            // sha1_update_vector_swap (&ctx, w, pw_len);
                            code.Add($"""
                                {currentAlgorithm.updateFunction}_vector_swap (&{context}, w, pw_len);
                            """);
                        }
                    }
                }
                else if (input == "salt")
                {
                    if (currentAlgorithm.endianness == Common.Endianness.LittleEndian)
                    {
                        if (attackVector != AttackVector.a3)
                        {
                            // md5_update (&ctx, s, salt_len);
                            code.Add($"{currentAlgorithm.updateFunction}(&{context}, s, salt_len);");
                        }
                        else
                        {
                            // md5_update_vector (&ctx, s, salt_len);
                            code.Add($"{currentAlgorithm.updateFunction}_vector(&{context}, s, salt_len);");
                        }
                    }
                    // TODO: Investigate if this can be eliminated by pre-hc_swapping the salts for a tiny amount of inner-loop performance
                    else
                    {
                        if (attackVector != AttackVector.a3)
                        {
                            // md5_update_swap (&ctx, s, salt_len);
                            code.Add($"{currentAlgorithm.updateSwapFunction}(&{context}, s, salt_len);");
                        }
                        else
                        {
                            // md5_update_swap_vector (&ctx, s, salt_len);
                            code.Add($"{currentAlgorithm.updateVectorSwapFunction}(&{context}, s, salt_len);");
                        }
                    }
                }
                // "input" is another context
                else if (contextAlgorithms.ContainsKey(input))
                {
                    IAlgorithm inputAlgorithm = contextAlgorithms[input];

                    // TODO: allow this
                    if (contextInputCounts.ContainsKey(context) == false)
                        throw new NotImplementedException("Cannot CUT the outer hash.");

                    // Place previous context's data in new context's w buffer
                    code.AddRange(LoadBuffers(inputAlgorithm, currentAlgorithm, contextInputCounts[context]));

                    if (inputAlgorithm.length >= 56 || contextInputCounts[context] != 1)
                    {
                        if(attackVector != AttackVector.a3)
                        {
                            // md5_update_64(&ctx, w0, w1, w2, w3, 64);
                            code.Add($"{currentAlgorithm.update64Function}(&{context}, w0, w1, w2, w3, {inputAlgorithm.length});");
                        }
                        else
                        {
                            // md5_update_vector_64(&ctx, w0, w1, w2, w3, 64);
                            code.Add($"{currentAlgorithm.update64VectorFunction}(&{context}, w0, w1, w2, w3, {inputAlgorithm.length});");
                        }

                    }
                    else
                    {
                        // ctx.len = 32;
                        code.Add($"{context}.len = {inputAlgorithm.length};");
                    }
                }
                else
                {
                    throw new Exception($"ERROR: Input parameter {input} not supported!");
                }

                code.Add("");

                // If the context name has changed or no more instructions left
                if (idx == instructions.Count - 1 || instructions[idx + 1].Split(" - ")[0].Replace(" ", "").Replace("-", "") != context)
                {
                    if (attackVector != AttackVector.a3)
                    {
                        // md5_final (&ctx);
                        code.Add($"{currentAlgorithm.finalFunction}(&{context});");
                    }
                    else
                    {
                        // md5_final_vector (&ctx);
                        code.Add($"{currentAlgorithm.finalFunction}_vector (&{context});");
                    }
                        code.Add("");
                }
            }
            return code;
        }

        public static CodeList GenerateFooter(string finalContext, AttackVector attackVector, KernelType kernelType)
        {
            CodeList code = new CodeList();

            finalContext = finalContext.Split(" - ")[0].Replace("-", "");

            // MultiHash = M, SingleHash = S
            string type = kernelType == KernelType.MultiHash ? "M" : "S";

            // a3 = SIMD, a0/a1 = SCALAR
            string comparer = attackVector == AttackVector.a3 ? "SIMD" : "SCALAR";

            // COMPARE_S_SIMD (ctx.h[DGST_R0], ctx.h[DGST_R1], ctx.h[DGST_R2], ctx.h[DGST_R3])
            code.Add($"COMPARE_{type}_{comparer} ({finalContext}.h[DGST_R0], {finalContext}.h[DGST_R1], {finalContext}.h[DGST_R2], {finalContext}.h[DGST_R3]);", 2);
            
            code.Add("}", 1);
            code.Add("}", 0);

            return code;
        }

        public static CodeList LoadBuffers(IAlgorithm source, IAlgorithm target, int inputs)
        {
            CodeList code = new CodeList();
            code.spacing = 2;

            int previousContextIdx = 0;
            int bytesProcessed = 0;

            int maskIdx = 0;
            int[] maskOffsets = new int[4];

            Conversion conversion;

            // Used to load either directly into the context.w buffers, or separate arrays for update_64
            // 56 bytes or less, it goes in context.w, any more than 56 and it goes into generic arrays
            string bufferTarget = "";
            if (source.length <= 56 && inputs == 1)
                bufferTarget = $"{target.context}.";

            // Set mask offsets for the hex conversion steps
            if (source.endianness == target.endianness)
            {
                if (source.endianness == Endianness.LittleEndian)
                {
                    conversion = Conversion.LE2LE;
                    maskOffsets = new int[] { 0, 8, 16, 24 };
                }
                else
                {
                    conversion = Conversion.BE2BE;
                    maskOffsets = new int[] { 16, 24, 0, 8 };
                }
            }
            else
            {
                if (source.endianness == Endianness.LittleEndian)
                {
                    conversion = Conversion.LE2BE;
                    maskOffsets = new int[] { 8, 0, 24, 16 };
                }
                else
                {
                    conversion = Conversion.BE2LE;
                    maskOffsets = new int[] { 24, 16, 8, 0 };
                }
            }

            for (int a = 0; a < source.byteLength; a++)
            {
                for (int b = 0; b < 4; b++)
                {
                    // Same internal logic, just different mask offsets so code can be reused safely, just with _le hex conversion
                    string suffix = "";

                    // LE -> LE, i.e MD5 -> MD5 or BE -> LE, i.e SHA1 -> MD5
                    if (conversion == Conversion.LE2LE || conversion == Conversion.BE2LE)
                    {
                        // Do nothing, keep suffix as ""
                    }
                    // BE -> BE, i.e SHA1 -> SHA1 or LE -> BE, i.e MD5 -> SHA1
                    else
                    {
                        suffix = "_le";
                    }
                    code.Add($"{bufferTarget}w{a}[{b}] =  uint_to_hex_lower8{suffix} (({source.context}.h[{previousContextIdx}] >>  {maskOffsets[maskIdx].ToString().PadLeft(2)}) & 255) <<  0");

                    maskIdx = (maskIdx + 1) % 4;

                    code.Add($"| uint_to_hex_lower8{suffix} (({source.context}.h[{previousContextIdx}] >>  {maskOffsets[maskIdx].ToString().PadLeft(2)}) & 255) << 16;".PadLeft(code.Last().Length + 1));

                    maskIdx = (maskIdx + 1) % 4;

                    bytesProcessed += 2;

                    // Skip out if there's still content to hex convert
                    if (bytesProcessed == source.byteLength)
                    {
                        // 0-out the remaining w0, w1, w2 and w3 buffers for safety
                        // This shouldn't be necessary but CUDA is annoying
                        // Just continues using the previous loops for ease. Janky but works
                        if (bufferTarget == "")
                        {
                            b++;
                            for (; a < 4; a++)
                            {
                                for (; b < 4; b++)
                                {
                                    code.Add($"w{a}[{b}] = 0;");
                                }
                                b = 0;
                            }
                        }

                        a = int.MaxValue - 1;
                        break;
                    }

                    if (b % 2 == 1)
                        previousContextIdx++;
                }
            }

            return code;
        }
    }
}
